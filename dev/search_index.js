var documenterSearchIndex = {"docs":
[{"location":"#NBT.jl","page":"Home","title":"NBT.jl","text":"Documentation for NBT.","category":"section"},{"location":"#Reading","page":"Home","title":"Reading","text":"The main way to read an NBT file is to use NBT.read. The main method takes a filename and returns a pair name => data. NBT files always consist of a single Compound tag filled with other tags, but the main outer tag is almost always unnamed, so typically NBT.read will output \"\" => LittleDict(...) and it's necessary to access the right element to get the data.\n\nNBT files are almost always compressed with GZip, but rarely aren't. To read NBT data from an uncompressed file, there is NBT.read_uncompressed which works in the same way as NBT.read. Both functions can also take an IO instead of a filename.\n\njulia> T = NBT.read(\"/home/intricate/mc/instances/1.17.1/minecraft/saves/New World/level.dat\")\n\"\" => OrderedCollections.LittleDict{String, Any, Vector{String}, Vector{Any}}(\"Data\" => OrderedCollections.LittleDict{String, Any, Vector{String}, Vector{Any}}(\"WanderingTraderSpawnChance\" => 25, \"BorderCenterZ\" => 0.0, \"Difficulty\" => 0x00, \"BorderSizeLerpTime\" => 0, \"raining\" => 0x00, \"Time\" => 265, \"GameType\" => 1, \"ServerBrands\" => [\"fabric\"], \"BorderCenterX\" => 0.0, \"BorderDamagePerBlock\" => 0.2…))\n\njulia> T[2]\nOrderedCollections.LittleDict{String, Any, Vector{String}, Vector{Any}} with 1 entry:\n  \"Data\" => LittleDict{String, Any, Vector{String}, Vector{Any}}(\"WanderingTraderSpawnChance\"=…\n\njulia> T[2][\"Data\"]\nOrderedCollections.LittleDict{String, Any, Vector{String}, Vector{Any}} with 42 entries:\n  \"WanderingTraderSpawnChance\" => 25\n  \"BorderCenterZ\"              => 0.0\n  \"Difficulty\"                 => 0x00\n  \"BorderSizeLerpTime\"         => 0\n  \"raining\"                    => 0x00\n  \"Time\"                       => 265\n  \"GameType\"                   => 1\n  \"ServerBrands\"               => [\"fabric\"]\n  \"BorderCenterX\"              => 0.0\n  \"BorderDamagePerBlock\"       => 0.2\n  \"BorderWarningBlocks\"        => 5.0\n  \"WorldGenSettings\"           => LittleDict{String, Any, Vector{String}, Vector{Any}}(\"bonus_…\n  \"DragonFight\"                => LittleDict{String, Any, Vector{String}, Vector{Any}}(\"NeedsS…\n  \"BorderSizeLerpTarget\"       => 6.0e7\n  \"Version\"                    => LittleDict{String, Any, Vector{String}, Vector{Any}}(\"Snapsh…\n  \"DayTime\"                    => 265\n  \"initialized\"                => 0x01\n  \"WasModded\"                  => 0x01\n  \"allowCommands\"              => 0x01\n  \"WanderingTraderSpawnDelay\"  => 24000\n  \"CustomBossEvents\"           => LittleDict{String, Any, Vector{String}, Vector{Any}}()\n  \"GameRules\"                  => LittleDict{String, Any, Vector{String}, Vector{Any}}(\"doFire…\n  \"Player\"                     => LittleDict{String, Any, Vector{String}, Vector{Any}}(\"Brain\"…\n  \"SpawnY\"                     => 1\n  \"rainTime\"                   => 169707\n  \"thunderTime\"                => 123751\n  \"SpawnZ\"                     => 8\n  \"hardcore\"                   => 0x00\n  \"DifficultyLocked\"           => 0x00\n  \"SpawnX\"                     => 8\n  \"clearWeatherTime\"           => 0\n  \"thundering\"                 => 0x00\n  \"SpawnAngle\"                 => 0.0\n  \"version\"                    => 19133\n  \"BorderSafeZone\"             => 5.0\n  \"LastPlayed\"                 => 1766296821236\n  \"BorderWarningTime\"          => 15.0\n  \"ScheduledEvents\"            => Any[]\n  \"LevelName\"                  => \"New World2\"\n  \"BorderSize\"                 => 6.0e7\n  \"DataVersion\"                => 2730\n  \"DataPacks\"                  => LittleDict{String, Any, Vector{String}, Vector{Any}}(\"Enable…\n\nFor convenience, NBT.jl provides the NBT.pretty_print function for printing the read data into the REPL. However, note that this will dump the entire file which may be very large.\n\njulia> NBT.pretty_print(T)\nUnnamed NBT file with 1 entries:\nData: {\n  WanderingTraderSpawnChance (Int32): 25\n  BorderCenterZ (Float64): 0.0\n  Difficulty: 0x00\n  BorderSizeLerpTime (Int64): 0\n  raining: 0x00\n  Time (Int64): 265\n  GameType (Int32): 1\n  ServerBrands: [\"fabric\"]\n  BorderCenterX (Float64): 0.0\n  BorderDamagePerBlock (Float64): 0.2\n  BorderWarningBlocks (Float64): 5.0\n  WorldGenSettings: {\n    bonus_chest: 0x00\n    seed (Int64): -7293489413437051478\n    generate_features: 0x01\n    dimensions: {\n      minecraft:overworld: {\n        generator: {\n          settings: \"minecraft:overworld\"\n          seed (Int64): -7293489413437051478\n          biome_source: {\n            seed (Int64): -7293489413437051478\n            large_biomes: 0x00\n            type: \"minecraft:vanilla_layered\"\n          }\n          type: \"minecraft:noise\"\n        }\n        type: \"minecraft:overworld\"\n      }\n      # [I'm cutting it off here to save space]","category":"section"},{"location":"#Writing","page":"Home","title":"Writing","text":"Writing works basically the same as reading. There is NBT.write which takes a filename and a name => data pair, and writes the data to the file. Similarly there is NBT.write_uncompressed for skipping compression.","category":"section"},{"location":"#Advanced-writing","page":"Home","title":"Advanced writing","text":"Sometimes you have existing data you want written to an NBT file, but it is not already in a nested Dict format, and converting would be an unnecessary intermediate step. To avoid having to convert the data to a specific format before writing, NBT.jl provides some lower-level writing functions. The main method is NBT.write_tag:\n\nThis function can take a pair name => data, or just data. The first method is intended for writing entries in a Compound tag, and the second for writing entries in a List tag. Combining NBT.write_tag with NBT.begin_nbt_file, NBT.end_nbt_file, NBT.begin_compound, NBT.end_compound, NBT.begin_list, and NBT.end_list, you can build an NBT file manually. Here is an example of how this can be used, taken from Litematica.jl:\n\nfunction Base.write(io::IO, litematic::Litematic)\n  s, bytes = begin_nbt_file(io)\n  bytes += write_tag(s, \"MinecraftDataVersion\" => litematic.data_version)\n  bytes += write_tag(s, \"Version\" => Int32(5))\n  bytes += write_tag(s, \"Metadata\" => litematic.metadata)\n  bytes += begin_compound(s, \"Regions\")\n\n  for region in litematic.regions\n    bytes += begin_compound(s, region.name)\n    bytes += write_tag(s, \"BlockStates\" => CompressedPalettedContainer(_permutedims(region.blocks, (1, 3, 2)), 2).data)\n    bytes += write_tag(s, \"PendingBlockTicks\" => TagList())\n    bytes += write_tag(s, \"Position\" => _writetriple(region.pos))\n    bytes += write_tag(s, \"BlockStatePalette\" => TagList(_Tag.(region.blocks.pool)))\n    bytes += write_tag(s, \"Size\" => _writetriple(Int32.(size(region.blocks))))\n    bytes += write_tag(s, \"PendingFluidTicks\" => TagList())\n    bytes += write_tag(s, \"TileEntities\" => TagList(TagCompound{Any}[t for t in region.tile_entities if t !== nothing]))\n    bytes += write_tag(s, \"Entities\" => TagList())\n    bytes += end_compound(s)\n  end\n\n  bytes += end_compound(s)\n  bytes += end_nbt_file(s)\n  return bytes\nend","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#NBT.read","page":"Home","title":"NBT.read","text":"read(filename)\n\nRead an NBT file and return the data as Julia objects.\n\n\n\n\n\nread(io)\n\nRead NBT data from an IO and return the data as Julia objects.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.read_uncompressed","page":"Home","title":"NBT.read_uncompressed","text":"read_uncompressed(io, ::Type{Tag})\n\nRead an nbt tag from an uncompressed IO.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.pretty_print","page":"Home","title":"NBT.pretty_print","text":"pretty_print(data, tab=\"  \")\n\nPrint the NBT data in data, using tab as the tab character. data can be an AbstractDict, a Vector, or a Pair{String, <:AbstractDict} (as output by read).\n\n\n\n\n\n","category":"function"},{"location":"#NBT.write","page":"Home","title":"NBT.write","text":"write(filename, pair::Pair{String, <:AbstractDict{String}})\n\nWrite an NBT file and return the number of bytes written.\n\n\n\n\n\nwrite(io, pair::Pair{String, <:AbstractDict{String}})\n\nWrite an NBT file to an IO and return the number of bytes written.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.write_uncompressed","page":"Home","title":"NBT.write_uncompressed","text":"write_uncompressed(filename, pair::Pair{String, <:AbstractDict{String}})\n\nWrite an NBT file to an uncompressed file and return the number of bytes written.\n\n\n\n\n\nwrite_uncompressed(io, pair::Pair{String, <:AbstractDict{String}})\n\nWrite an NBT file to an uncompressed IO and return the number of bytes written.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.write_tag","page":"Home","title":"NBT.write_tag","text":"write_tag(io, data)\n\nWrite the data tag and return the number of bytes written. Use only after begin_list.\n\n\n\n\n\nwrite_tag(io, name => data)\n\nWrite the name => data pair and return the number of bytes written. Use only between begin_compound and end_compound.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.begin_nbt_file","page":"Home","title":"NBT.begin_nbt_file","text":"begin_nbt_file(io)\n\nBegin an NBT file and return a stream and the number of bytes written.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.end_nbt_file","page":"Home","title":"NBT.end_nbt_file","text":"end_nbt_file(io)\n\nEnd an NBT file and return the number of bytes written.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.begin_compound","page":"Home","title":"NBT.begin_compound","text":"begin_compound(io, name)\n\nBegin an NBT Compound tag and return the number of bytes written. Use only for the root tag (with an empty name) or between begin_compound and end_compound.\n\n\n\n\n\nbegin_compound(io)\n\nBegin an NBT Compound tag and return the number of bytes written. Use only after begin_list.\n\nNote: This method just returns 0, but is included for completeness and to allow for more readable code.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.end_compound","page":"Home","title":"NBT.end_compound","text":"end_compound(io)\n\nEnd the current NBT Compound tag and return the number of bytes written.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.begin_list","page":"Home","title":"NBT.begin_list","text":"begin_list(io, name, length, type)\n\nBegin an NBT List tag with the specified length and element type and return the number of bytes written. Use only between begin_compound and end_compound.\n\n\n\n\n\nbegin_list(io, length, type)\n\nBegin an NBT List tag with the specified length and element type and return the number of bytes written. Use only after begin_list.\n\n\n\n\n\n","category":"function"},{"location":"#NBT.end_list","page":"Home","title":"NBT.end_list","text":"end_list(io)\n\nEnd an NBT List tag and return the number of bytes written.\n\nNote: This method just returns 0, but is included for completeness and to allow for more readable code.\n\n\n\n\n\n","category":"function"}]
}
